# 自己的笔试记录
##  贝壳



选择 | 算法
---|---
递归 | 取消社团预约
分枝限界法 | 搭建道路
平衡二叉树 | 扑克牌（斗地主）
建立小顶堆 |
最小生成树 |
concat（） |
mysql存储过程优缺点|
磁盘调度算法 |
词法分析 | 
操作系统的安全执行序列 |
ipv6长度|

### 选择

1.递归
```
必须要有终止条件
可与迭代相互转化
可以通过栈来模拟实现
```
2.分支限界法

```
1. 分支限界法思想：
分支限界法首先要确定一个合理的限界函数（bound funciton），
并根据限界函数确定目标函数的界[down ,up]，按照广度优先策略搜索问题的解空间树，
在分直结点上依次扩展该结点的孩子结点，分别估算孩子结点的目标函数可能值，
如果某孩子结点的目标函数可能超出目标函数的界，则将其丢弃；否则将其加入待处理结点表（简称PT表），
依次从表PT中选取使目标函数取得极值的结点成为当前扩展结点，重复上述过程，直到得到最优解。
2 分支限界法与回溯法：
求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，
而分支限界法的求解目标则是找出满足约束条件的一个解，
或是在满足约束条件的解中找出在某种意义下的最优解。
搜索方式的不同：回溯法以深度优先的方式搜索解空间树，
               而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。
3. 常见的两种分支限界法：
队列式(FIFO)分支限界法 
按照队列先进先出（FIFO）原则选取下一个结点为扩展结点。
优先队列式分支限界法 
按照优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点。
```

3.平衡二叉树

```
平衡二叉树的前提是它是一棵二叉排序树。 
距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。
如下图所示，当插入结点37时，距离它最近的平衡因子的绝对值超过1的结点是58。
```
![image](471412213B9A43B4A2D9363F0F1B877A)
```
通过左旋右旋来实现平衡因子不大于1
```
![image](36A0A89971B645B987EB8706B072731E)

> 建树过程

```

```

4.建立小顶堆
```
小顶堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节点的值。
小顶堆的堆顶的关键字是所有关键字中最小的。

```
5.最小生成树
```
一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。
最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。

Prim算法简述
1).输入：一个加权连通图，其中顶点集合为V，边集合为E；
2).初始化：Vnew= {x}，其中x为集合V中的任一节点（起始点），Enew= {},为空；
3).重复下列操作，直到Vnew= V：
a.在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；
b.将v加入集合Vnew中，将<u, v>边加入集合Enew中；
4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。

Kruskal算法简述
假设 WN=(V,{E}) 是一个含有 n 个顶点的连通网，则按照克鲁斯卡尔算法构造最小生成树的过程为：
先构造一个只含 n 个顶点，而边集为空的子图，
若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有 n 棵树的一个森林。
之后，从网的边集 E 中选取一条权值最小的边，
若该条边的两个顶点分属不同的树，则将其加入子图，也就是说，将这两个顶点分别所在的两棵树合成一棵树；
反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。
依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。
```
6.concat()

```
concat() 方法用于连接两个或多个数组。(javascript中的)

该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
```
7.mysql存储过程的优缺点
```
存储过程是一组预先创建并用指定的名称存储在数据库服务器上的 SQL 语句，
将使用比较频繁或者比较复杂的操作，预先用 SQL 语句写好并存储起来，
以后当需要数据库提供相同的服务时，只需再次执行该存储过程。
一、存储过程优点 
存储过程是一组预先创建并用指定的名称存储在数据库服务器上的 SQL 语句，
将使用比较频繁或者比较复杂的操作，预先用 SQL 语句写好并存储起来，
以后当需要数据库提供相同的服务时，只需再次执行该存储过程。
1.具有更好的性能
存储过程是预编译的，只在创建时进行编译，以后每次执行存储过程都不需再重新编译，
而一般 SQL 语句每执行一次就编译一次，因此使用存储过程可以提高数据库执行速度。
2.功能实现更加灵活
存储过程中可以应用条件判断和游标等语句，有很强的灵活性
，可以直接调用数据库的一些内置函数，完成复杂的判断和较复杂的运算。
3.减少网络传输
复杂的业务逻辑需要多条 SQL 语句，当客户机和服务器之间的操作很多时，将产生大量的网络传输。
如果将这些操作放在一个存储过程中，那么客户机和服务器之间的网络传输就会减少，降低了网络负载。
4.具有更好的安全性
（1）数据库管理人员可以更好的进行权限控制，
存储过程可以屏蔽对底层数据库对象的直接访问，使用 EXECUTE 权限调用存储过程，
无需拥有访问底层数据库对象的显式权限。
（2）在通过网络调用过程时，只有对执行过程的调用是可见的。
无法看到表和数据库对象名称，不能嵌入SQL 语句，有助于避免 SQL 注入攻击。
二、缺点
1.SQL本身是一种结构化查询语言，加上了一些控制（赋值、循环和异常处理等），
但不是OO的，本质上还是过程化的，面对复杂的业务逻辑，过程化的处理会很吃力。
这一点算致命伤。

2.不便于调试。基本上没有较好的调试器，很多时候是用print来调试，
但用这种方法调试长达数百行的存储过程简直是噩梦。

3.没办法应用缓存。虽然有全局临时表之类的方法可以做缓存，但同样加重了数据库的负担。
如果缓存并发严重，经常要加锁，那效率实在堪忧。

4.无法适应数据库的切割（水平或垂直切割）。
数据库切割之后，存储过程并不清楚数据存储在哪个数据库中。

5.精通SQL的新手越来越少——不要笑，这是真的，我面试过N多新人，
都不知道如何创建全局临时表、不知道having、不知道聚集索引和非聚集索引，
更别提游标和提交叉表查询了。好吧，这个缺点算是凑数用的，
作为屌丝程序员，我们的口号是：没有不会的，只有不用的。
除了少数有语言洁癖的人，我相信精通SQL只是时间问题。
```
8.磁盘调度算法
```
  先来先服务算法（FCFS ），
  最短寻道时间优先算法（SSTF ），
  扫描算法（SCAN ），
  循环扫描算法（CSCAN ）
例:  假定某磁盘共有200个柱面，编号为 0-199，如果在为访问 143
号柱面的请求者服务后，当前正在为访问 125
号柱面的请求服务，同时有若干请求者在等待服务，它们每次要访问的柱面号为 86
，147 ，91 ，177 ，94 ，150 ，102， 175 ，130
1 、先来先服务算法（FCFS ）First Come First Service
这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。
此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。
此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，
此算法将降低设备服务的吞吐量，致使平均寻道时间可能较长，
但各进程得到服务的响应时间的变化幅度较小。
先来先服务 （125）86.147.91.177.94.150.102.175.130
2 、最短寻道时间优先算法（SSTF ） Shortest Seek Time First
该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，
该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。
其缺点是对用户的服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。
在服务请求很多的情况下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。
最短寻道时间优先（125）130.147.150.175.177.102.94.91.86
3 、扫描算法（SCAN ）电梯调度
扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。
例如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。
这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。
这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁道之内，从而避免了饥饿现象的出现。
由于这种算法中磁头移动的规律颇似电梯的运行，故又称为电梯调度算法。
此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间变化比较大的缺点，
而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。
电梯调度（125）102.94.91.86.130.147.150.175.177
4 、循环扫描算法（CSCAN ）
循环扫描算法是对扫描算法的改进。
如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。
这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。
例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。
循环扫描 （125）130.147.150.175.177.86.91.94.102
5 、平均寻道距离
假设当前磁头在 67 号，要求访问的磁道号顺序为 98,25,63,97,56,51,55,55,6
FIFO 算法的服务序列是：98,25,63,97,56,51,55,55,6
磁头移动的总距离 distance =
(98-67)+(98-25)+(63-25)+(97-63)+(97-56)+(56-51)+(55-51)+(55-55)+(55-6)
SSTF 算法的服务序列是: 63,56,55,55,51,25,6,97,98
磁头移动的总距离 distance =
(67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+(97-6)+(98-97)
SCAN 算法的服务序列是：63,56,55,55,51,25,6,97,98
磁头移动的总距离 distance =
(67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+(97-6)+(98-97)
我发现这里例子举的不好，SSTF 和 SCAN 算法的服务序列竟是一样的，尴
尬！
CSCAN 算法的服务序列是：63,56,55,55,51,25,6,98,97
磁头移动的总距离 distance =
(67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+(100-98)+(98-97)
```
9.词法分析阶段的错误
```

```
10.操作系统的安全执行序列
```

```
11.ipv6长度
```
128
```

### 算法

1.取消社团预约
> 题目描述：
在中国某大学内，教室资源十分紧张，有n个社团同时申请了在某一天使用同一间教室，假设第i个社团占用该教室的时间记为[li,  ri]。根据学校的规定，教务部门必须且最多取消一个社团的预约，来满足另外n-1个社团的需求，问学校有多少种取消的方案。(若两社团占用时间分别为[l1, r1]和[l2,  r2]，此时若r1=l2，视为时间没有冲突)

> 输入


```
第一行包含一个整数n，表示社团的数量。(1≤n≤5000)。

接下来有n行，每行包含两个整数，表示第i个社团占用该教室的时间为[li, ri](1≤li, ri≤106)
```


> 输出


```
输出第一行包含一个整数m，表示可以删去的社团数量。

输出第二行包含m个整数，分别为可删除的社团编号(从小到大排序)。

（如不删除某个预约，则不能算作一种方案。）
```


> 样例

```
样例输入
3
3 10
20 30
1 3
样例输出
3
1 2 3

输入样例
4
3 10
20 30
1 3
1 39

输出样例
1
4

输入样例
3
1 5
2 6
3 7

输出样例
0

样例解释
样例1中删除 1，2 ，3社团中的任何一个都可以使得另外两个社团无冲突的使用教室
样例2中删除4以后【1，3】【3，10】【20，30】无冲突，若删除1，2，3中任何一个都会与4冲突。
```



2.道路修建

> 题目描述：
山区里有N个村庄，第i个村庄的海拔高度为Ai。现在要在村庄之间修建道路，使得从每个村庄出发，都能到达其它所有村庄。在第i和第j个村庄之间修建道路的费用取决于海拔较高的村庄的高度，即费用为max{Ai，Aj}，那么修建道路的总费用最少是多少？

> 输入


```
第一行包含一个整数N，2≤N≤105。

第二行包含N个空格隔开的整数A1到AN，0≤Ai≤104。
```


> 输出


```
输出修建道路的最小费用。
```

> 样例


```
样例输入
5
4 1 8 2 5
样例输出
19
```
3.扑克牌

> 题目描述：
众所周知，一副扑克牌按大小分为13种牌，每种牌各4个花色，总共52张牌。规定13种牌按从小到大的顺序分别为A23456789TJQK，现在从一副牌中抽取20张，每轮选择下列规则中的一项出牌：
①单牌：任意一张牌，如Q；
②对子：两张大小相同的牌，如77；
③三带：三张大小相同的牌，附带至多一张任意牌，如333A；
④四带：四张大小相同的牌，附带至多两张任意牌，如KKKK58；
⑤顺子：至少五张大小连续的牌，如789TJQ。
那么，至少需要多少轮才能将20张牌出完？

> 输入

```
输入长度为20的字符串，表示所抽取的20张牌。
```


> 输出

```
输出将20张牌出完所需的最少轮数。
```

> 样例


```
样例输入
8K67A65K27T59K346AK2
样例输出
4

样例解释
4轮出牌顺序为：
A234567
56789T
KKKKA2
6
```
